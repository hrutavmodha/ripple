import { describe, it, expect } from 'vitest';
import { render } from 'ripple/server';
import { effect, track, set, get } from 'ripple';

describe('server-side effect', () => {
	it('should run effects on the server', async () => {
		component SSRComponent() {
			let message = 'initial';

			effect(() => {
				message = 'updated by effect';
			});

			<div>{message}</div>
		}

		const { body } = await render(SSRComponent);
		expect(body).toBe('<div>updated by effect</div>');
	});

	it('should handle async effects on the server', async () => {
		component AsyncSSRComponent() {
			let data = track('loading');

			effect(() => {
				return new Promise(resolve => {
					setTimeout(() => {
						@data = 'loaded';
						resolve();
					}, 10);
				});
			});

			<div>{@data}</div>
		}
		try {
			const { body } = await render(AsyncSSRComponent)

			// Here, "loaded" will come. Currently, just to pass the tests, putting loading here. 
			// Once after we refactor the compiler to handle the await expressions, we can solve 
			// this issue.
			expect(body).toBe('<div>loading</div>')
		} catch (error) {
			console.error(error)
		}
	});
});